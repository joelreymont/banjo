;;; banjo-test.el --- Tests for banjo.el -*- lexical-binding: t -*-

(require 'ert)
(require 'cl-lib)

(defun banjo-test--ensure-websocket ()
  (unless (require 'websocket nil t)
    (let ((candidates (list
                       (expand-file-name "~/.config/emacs/.local/straight/build-*/websocket")
                       (expand-file-name "~/.config/emacs/.local/straight/repos/emacs-websocket"))))
      (dolist (pattern candidates)
        (dolist (path (file-expand-wildcards pattern))
          (when (file-directory-p path)
            (add-to-list 'load-path path)))))
    (unless (require 'websocket nil t)
      (error "websocket.el not found; install emacs-websocket"))))

(banjo-test--ensure-websocket)
(require 'banjo)

(defun banjo-test--wait-until (pred timeout)
  (let ((deadline (+ (float-time) timeout))
        (done nil))
    (while (and (not done) (< (float-time) deadline))
      (accept-process-output nil 0.05)
      (setq done (funcall pred)))
    done))

(defun banjo-test--assistant-output-p ()
  (with-current-buffer (banjo--get-output-buffer)
    (save-excursion
      (goto-char (point-min))
      (when (search-forward "\n\n" nil t)
        (re-search-forward "\\S-" nil t)))))

(defun banjo-test--exec-command (command &optional input)
  (let ((keys (if input
                  (vconcat (kbd (format "M-x %s RET" command)) input (kbd "RET"))
                (kbd (format "M-x %s RET" command)))))
    (execute-kbd-macro keys)
    (accept-process-output nil 0.05)))

(defun banjo-test--send-from-input (text)
  (banjo-test--exec-command "banjo-focus-input")
  (let ((input (banjo--get-input-buffer)))
    (with-current-buffer input
      (let ((inhibit-read-only t))
        (erase-buffer))))
  (execute-kbd-macro (vconcat text (kbd "RET")))
  (accept-process-output nil 0.05))

(defun banjo-test--e2e-run (engine prompt)
  (let* ((lib (locate-library "banjo"))
         (emacs-dir (and lib (file-name-directory lib)))
         (root (and emacs-dir (file-name-directory (directory-file-name emacs-dir))))
         (root-ok (and root (not (string-match-p "/\\.local/straight/build-" root))))
         (repo-root (and (getenv "BANJO_REPO_ROOT")
                         (file-name-as-directory (getenv "BANJO_REPO_ROOT"))))
         (banjo-bin (or (and banjo-binary (file-executable-p banjo-binary) banjo-binary)
                        (executable-find (or banjo-binary "banjo"))
                        (and repo-root (expand-file-name "zig-out/bin/banjo" repo-root))
                        (and root-ok (expand-file-name "zig-out/bin/banjo" root))))
         (temp-dir (make-temp-file "banjo-emacs-e2e-" t))
         (default-directory (file-name-as-directory temp-dir))
         (banjo--output-buffer (format "*banjo-test-e2e-%s*" engine))
         (banjo-binary banjo-bin)
         (process-environment (copy-sequence process-environment))
         (exec-path (append exec-path (parse-colon-path (or (getenv "PATH") ""))))
         (codex (executable-find "codex"))
         (claude (executable-find "claude")))
    (should (and banjo-bin (file-executable-p banjo-bin)))
    (pcase engine
      ('codex
       (should codex)
       (setenv "CODEX_EXECUTABLE" codex)
       (setenv "BANJO_ROUTE" "codex")
       (setenv "BANJO_PRIMARY_AGENT" "codex"))
      ('claude
       (should claude)
       (setenv "CLAUDE_CODE_EXECUTABLE" claude)
       (setenv "BANJO_ROUTE" "claude")
       (setenv "BANJO_PRIMARY_AGENT" "claude")))
    (setenv "BANJO_AUTO_RESUME" "false")
    (unwind-protect
        (progn
          (banjo-test--exec-command "banjo-stop")
          (setq banjo--process-output "")
          (banjo-test--exec-command "banjo-start")
          (should (banjo-test--wait-until (lambda () banjo--session-id) 15.0))
          (banjo-test--send-from-input prompt)
          (should (banjo-test--wait-until #'banjo-test--assistant-output-p 20.0)))
      (banjo-test--exec-command "banjo-stop")
      (delete-directory temp-dir t))))

(ert-deftest banjo-test-split-fence-chunks ()
  (let ((banjo--output-buffer "*banjo-test*"))
    (banjo--clear-output)
    (banjo--append-output "``")
    (banjo--append-output "`\ncode\n")
    (banjo--append-output "```\nplain\n")
    (with-current-buffer (banjo--get-output-buffer)
      (goto-char (point-min))
      (search-forward "code")
      (should (get-text-property (match-beginning 0) 'banjo-code-block))
      (search-forward "plain")
      (should-not (get-text-property (match-beginning 0) 'banjo-code-block)))))

(ert-deftest banjo-test-link-skipped-in-code-block ()
  (let* ((banjo--output-buffer "*banjo-test*")
         (tmp (make-temp-file "banjo-link-")))
    (unwind-protect
        (progn
          (banjo--clear-output)
          (banjo--append-output (format "```\n%s\n```\n" tmp))
          (with-current-buffer (banjo--get-output-buffer)
            (goto-char (point-min))
            (search-forward tmp)
            (should (get-text-property (match-beginning 0) 'banjo-code-block))
            (should-not (get-text-property (match-beginning 0) 'banjo-link))))
      (delete-file tmp))))

(ert-deftest banjo-test-panel-layout ()
  (let ((banjo--output-buffer "*banjo-test-output*")
        (banjo--input-buffer "*banjo-test-input*"))
    (banjo-test--exec-command "banjo-focus-input")
    (let ((out-win (get-buffer-window (banjo--get-output-buffer)))
          (in-win (get-buffer-window (banjo--get-input-buffer))))
      (should out-win)
      (should in-win)
      (let* ((out-edges (window-edges out-win))
             (in-edges (window-edges in-win)))
        (should (< (nth 1 out-edges) (nth 1 in-edges)))))))

(ert-deftest banjo-test-buffer-vars-reinit ()
  (let ((banjo--output-buffer "*banjo-test-output*")
        (banjo--input-buffer "*banjo-test-input*"))
    (makunbound 'banjo--output-buffer)
    (makunbound 'banjo--input-buffer)
    (banjo-test--exec-command "banjo-focus-input")
    (should (string= banjo--output-buffer "*banjo*"))
    (should (string= banjo--input-buffer "*banjo-input*"))))

(ert-deftest banjo-test-input-map-reinit ()
  (let ((banjo--output-buffer "*banjo-test-output*")
        (banjo--input-buffer "*banjo-test-input*"))
    (when (boundp 'banjo-input-mode-map)
      (makunbound 'banjo-input-mode-map))
    (banjo-test--exec-command "banjo-focus-input")
    (should (keymapp banjo-input-mode-map))))

(ert-deftest banjo-test-input-no-line-numbers ()
  (let ((banjo--input-buffer "*banjo-test-input*"))
    (with-current-buffer (banjo--get-input-buffer)
      (should (bound-and-true-p doom-disable-line-numbers))
      (should (null display-line-numbers))
      (when (boundp 'display-line-numbers-type)
        (should (null display-line-numbers-type)))
      (when (boundp 'display-line-numbers-mode)
        (should (not display-line-numbers-mode))))))

(ert-deftest banjo-test-user-message-separation ()
  (let ((banjo--output-buffer "*banjo-test-output*"))
    (banjo--clear-output)
    (banjo--append-output "Assistant\n" 'banjo-face-assistant)
    (banjo--append-user-message "hello")
    (with-current-buffer (banjo--get-output-buffer)
      (should (string-match-p "Assistant\n\nhello\n\n" (buffer-string))))))

(ert-deftest banjo-test-make-request-jsonrpc ()
  (let* ((json-object-type 'alist)
         (json-key-type 'symbol)
         (json-array-type 'vector)
         (params '((text . "hello") (files . []) (cwd . "/tmp")))
         (request-json (json-encode (banjo--make-request "prompt" params 7)))
         (request (json-read-from-string request-json))
         (note-params '((text . "Ready")))
         (note-json (json-encode (banjo--make-request "status" note-params)))
         (note (json-read-from-string note-json)))
    (should (equal (alist-get 'jsonrpc request) "2.0"))
    (should (equal (alist-get 'id request) 7))
    (should (equal (alist-get 'method request) "prompt"))
    (should (equal (alist-get 'params request) params))
    (should (equal (alist-get 'jsonrpc note) "2.0"))
    (should (equal (alist-get 'method note) "status"))
    (should (equal (alist-get 'params note) note-params))
    (should-not (string-match-p "\"id\"" note-json))))

(ert-deftest banjo-test-slash-command-help ()
  (let ((banjo--output-buffer "*banjo-test-output*"))
    (banjo--clear-output)
    (should (banjo--dispatch-command "help" ""))
    (with-current-buffer (banjo--get-output-buffer)
      (goto-char (point-min))
      (should (search-forward "Available commands:" nil t)))))

(ert-deftest banjo-test-input-face-remap ()
  (let ((banjo--input-buffer "*banjo-test-input*"))
    (banjo--get-input-buffer)
    (with-current-buffer (banjo--get-input-buffer)
      (should (or (assq 'default face-remapping-alist)
                  (bound-and-true-p buffer-face-mode))))))

(ert-deftest banjo-test-evil-slash-binding-setup ()
  (let ((features (cons 'evil features)))
    (eval '(defmacro evil-define-key (&rest _args) nil))
    (banjo--setup-evil-panel-bindings)
    (should (keymapp banjo-input-mode-map))))

(ert-deftest banjo-test-history-nav ()
  (let ((banjo-history-dir (make-temp-file "banjo-hist-" t))
        (banjo--history nil)
        (banjo--history-index 0)
        (banjo--history-temp nil)
        (banjo--history-key nil)
        (banjo--input-buffer "*banjo-test-input*"))
    (unwind-protect
        (progn
          (banjo--history-ensure default-directory)
          (banjo--history-add "first")
          (banjo--history-add "second")
          (with-current-buffer (banjo--get-input-buffer)
            (banjo--set-input-text "draft")
            (banjo-history-prev)
            (should (string= (buffer-string) "second"))
            (banjo-history-prev)
            (should (string= (buffer-string) "first"))
            (banjo-history-next)
            (should (string= (buffer-string) "second"))
            (banjo-history-next)
            (should (string= (buffer-string) "draft"))))
      (delete-directory banjo-history-dir t))))

(ert-deftest banjo-test-command-completion ()
  (let ((banjo--input-buffer "*banjo-test-input*"))
    (with-current-buffer (banjo--get-input-buffer)
      (banjo--set-input-text "/he")
      (goto-char (point-max))
      (let ((capf (banjo--completion-at-point)))
        (should capf)
        (should (member "help" (nth 2 capf)))))))

(ert-deftest banjo-test-autoscroll-toggle ()
  (let ((banjo-autoscroll t))
    (banjo-toggle-autoscroll)
    (should (not banjo-autoscroll))))

(ert-deftest banjo-test-code-fold ()
  (let ((banjo--output-buffer "*banjo-test-output*"))
    (banjo--clear-output)
    (banjo--append-output "```\ncode\n```\n")
    (with-current-buffer (banjo--get-output-buffer)
      (goto-char (point-min))
      (search-forward "code")
      (banjo-toggle-code-fold)
      (should (banjo--find-fold-overlay (point)))
      (banjo-toggle-code-fold)
      (should-not (banjo--find-fold-overlay (point))))))

(ert-deftest banjo-test-mode-line-status ()
  (let ((banjo-autoscroll nil)
        (banjo--state (list :engine "codex" :model "x" :mode "acceptEdits"))
        (banjo--websocket 'test))
    (cl-letf (((symbol-function 'websocket-openp) (lambda (_ws) t)))
      (banjo--update-mode-line)
      (should (string-match-p "Banjo\\[codex/x" banjo--mode-line-string))
      (should (string-match-p "hold" banjo--mode-line-string)))))

(ert-deftest banjo-test-doom-prefix-availability ()
  (let ((orig-bound (boundp 'doom-leader-map))
        (orig (and (boundp 'doom-leader-map) doom-leader-map)))
    (unwind-protect
        (progn
          (setq doom-leader-map (make-sparse-keymap))
          (should (banjo--ensure-doom-prefix-map "a"))
          (define-key doom-leader-map (kbd "a") #'ignore)
          (should (banjo--ensure-doom-prefix-map "a"))
          (should (keymapp (lookup-key doom-leader-map (kbd "a")))))
      (if orig-bound
          (setq doom-leader-map orig)
        (makunbound 'doom-leader-map)))))

(ert-deftest banjo-test-doom-keybindings-skip-non-prefix ()
  (let ((orig-bound (boundp 'doom-leader-map))
        (orig (and (boundp 'doom-leader-map) doom-leader-map))
        (features (cons 'doom-keybinds features))
        (banjo-doom-leader-prefix "a"))
    (unwind-protect
        (progn
          (setq doom-leader-map (make-sparse-keymap))
          (define-key doom-leader-map (kbd "a") #'ignore)
          (should (banjo--define-doom-leader-keys "a"))
          (let ((map (lookup-key doom-leader-map (kbd "a"))))
            (should (keymapp map))
            (should (eq (lookup-key map (kbd "b")) #'banjo-toggle))))
      (if orig-bound
          (setq doom-leader-map orig)
        (makunbound 'doom-leader-map)))))

(ert-deftest banjo-test-evil-define-key-missing ()
  (let ((orig-bound (boundp 'doom-leader-map))
        (orig (and (boundp 'doom-leader-map) doom-leader-map))
        (features (cons 'evil (cons 'doom-keybinds features)))
        (banjo-doom-leader-prefix "a")
        (orig-fn (and (fboundp 'evil-define-key) (symbol-function 'evil-define-key))))
    (unwind-protect
        (progn
          (setq doom-leader-map (make-sparse-keymap))
          (define-key doom-leader-map (kbd "a") #'ignore)
          (when (fboundp 'evil-define-key)
            (fmakunbound 'evil-define-key))
          (should (condition-case nil
                      (progn (banjo--setup-doom-keybindings) t)
                    (error nil))))
      (when orig-fn
        (fset 'evil-define-key orig-fn))
      (if orig-bound
          (setq doom-leader-map orig)
        (makunbound 'doom-leader-map)))))

(ert-deftest banjo-test-byte-compile-evil-macro ()
  (let* ((lib (locate-library "banjo"))
         (src (cond
               ((and lib (string-match-p "\\.el\\'" lib)) lib)
               ((and lib (string-match-p "\\.elc\\'" lib))
                (let ((el (concat (file-name-sans-extension lib) ".el")))
                  (if (file-exists-p el) el lib)))
               (t lib)))
         (tmp-dir (make-temp-file "banjo-compile-" t))
         (tmp-src (expand-file-name "banjo.el" tmp-dir))
         (tmp-elc (expand-file-name "banjo.elc" tmp-dir))
         (features (cons 'evil features)))
    (unwind-protect
        (progn
          (should src)
          (copy-file src tmp-src t)
          (let ((byte-compile-warnings nil))
            (byte-compile-file tmp-src))
          (eval '(defmacro evil-define-key (&rest _args) nil))
          (should (condition-case nil
                      (load tmp-elc nil t)
                    (error nil))))
      (delete-directory tmp-dir t))))

(ert-deftest banjo-test-emacs-end-to-end ()
  (banjo-test--e2e-run 'codex "Reply with a short greeting.")
  (banjo-test--e2e-run 'claude "Reply with a short greeting."))

(provide 'banjo-test)
;;; banjo-test.el ends here
